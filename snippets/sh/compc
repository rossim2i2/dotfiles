#!/usr/bin/bash

# This snippet contains the scaffolding for Bash tab completion using
# the complete -C foo foo variation which allows scripts to complete
# themselves (rather than having another script somewhere to manage). To
# use it simply add a function with the additional command and add the
# name of it to the commands array declaration at the top of the script.
# Then add complete -C foo foo (or something like it) to your bashrc.
# Begin functions with x_ to allow useful command names to be used that
# would otherwise conflict with existing system and bash keywords.

x_usage() {
    local cmds="${COMMANDS[@]}"
    printf "usage: ${0##*/} (${cmds// /|})\n"
}

# --------------------- completion and delegation --------------------

declare -a COMMANDS=()

while read -r line; do
    [[ $line =~ ^declare\ -f\ x_ ]] || continue
    COMMANDS+=( ${line##declare -f x_} )
done < <(declare -F)

if [[ -n $COMP_LINE ]]; then
    for c in "${COMMANDS[@]}"; do
        [[ ${c:0:${#2}} == "${2,,}" ]] && echo "$c"
    done
    exit
fi

declare cmd="$1"; shift
for c in "${COMMANDS[@]}"; do
    if [[ $c == "$cmd" ]]; then
        "x_$cmd" "$@"
        exit $?
    fi
done

x_usage "$@"
