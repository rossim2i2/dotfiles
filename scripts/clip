#!/usr/bin/bash
# shellcheck disable=SC2016
set -e

# Copyright 2021 Rob Muhlestein <rob@rwx.gg>
# Released under Apache-2.0 License
# Please mention https://youtube.com/rwxrob

: ${CLIP_DATA:="$HOME/.config/clip/data"}
: ${CLIP_DIR:="$HOME/Videos/clips"}
: ${CLIP_SCREEN:=1}
: ${CLIP_VOLUME:=-50}
: ${PAGER:=more}
: ${EDITOR:=vi}
: ${HELP_BROWSER:=}

EXE="${0##*/}"

declare -A help

help[main]='
The `clip` utility (a bash script) is for downloading managing and
playing clips from videos in full screen from the command line.

## Dependencies

Required:

* `bash` (4+)
* `mpv`
* `youtube-dl`

Will use if detected:

* `keyon` / `keyoff`
* `pandoc`

Environment variables:

```
: ${CLIP_DATA:="$HOME/.config/clip/data"}
: ${CLIP_DIR:="$HOME/Videos/clips"}
: ${CLIP_SCREEN:=1}
: ${CLIP_VOLUME:=-50}
: ${PAGER:=more}
: ${EDITOR:=vi}
: ${HELP_BROWSER:=}
```

## Usage

```
clip dir
clip data [<name>]
clip add <name> <url>
clip edit
clip help [<command>]
clip list
clip (play) [<name>]
clip usage
```
## Commands

* [usage] - print usage summary 
* [play]  - play clip, randomize if duplicates, select menu if none
* [list]  - print list of all clips by name
* [data]  - print data for name (random if dupicates)
* [dir]   - print directory path containing clip videos
* [add]   - download and add video from YouTube URL
* [edit]  - open data file for editing with `$EDITOR`
* [help]  - display help for all or specified command

[usage]: help-clip-usage.html
[play]: help-clip-play.html
[list]: help-clip-list.html
[data]: help-clip-data.html
[dir]: help-clip-dir.html
[add]: help-clip-add.html
[edit]: help-clip-edit.html
[help]: help-clip-help.html

'

help[edit]='
The `edit` command opens the clip data file (`CLIP_DATA`) with the current `$EDITOR` (default: `vi`).
'

x_edit() { "$EDITOR" "$CLIP_DATA"; }

help[data]='
The `data` command returns a line from the data file (`$CLIP_DATA`) that
matches the argument passed, which can be simply a string or an extended
regular expression. If more than one line matches, then one will randomly be returned.'

x_data() {
  _filter "$@"
  local -a data
  mapfile -t data < "$CLIP_DATA"
  local -a matches
  IFS=$'\n'
  for c in "${data[@]}";do
    [[ $c =~ ^$1 ]] && matches+=($c)
  done
  echo "${matches[$((RANDOM%${#matches[@]}))]}"
}

help[play]='
The `play` command (which is the default when no command is passed)
takes the basename of a video in the `$CLIP_DIR` and plays it with
passed volume (100), starting point (0), and length (10). If the name
passed refers to one or more clips, a random clip from among them will
be select. Also, rather than a specific, any Bash-compatible regular
expression may be passed allowing for interesting combinations. For
example, a `coin` alias could be created to select randomly from between
the *yes* and *no* clips, which could themselves also have multiple in
their groups. (See `man mpv` for more details on how the videos are
played.) '

x_play() {
  if [[ -z "$1" ]]; then
    select c in $(x_list); do
      x_play "$c" || true
    done
    return $?
  fi
  type keyoff &>/dev/null && (keyoff || true)
  local -a data
  data=($(x_data "$@"))
  local out
  local -i volume=$CLIP_VOLUME
  volume+=${data[1]:-100}
  mpv --fs \
    "--volume=$volume" \
    "--start=${data[2]:-0}" \
    "--length=${data[3]:-10}" \
    "--fs-screen=$CLIP_SCREEN" \
    $CLIP_DIR/${data[4]} &> /dev/null
  type keyon &>/dev/null && (keyon || true)
}

help[add]='
The `add` command will download the provided YouTube URL into the
`$CLIP_DIR` directory and name it according the YouTube identifier
preserving the same file suffix. It then add an entry to the clips data
file (`$CLIP_DATA`) with default settings which can be changed easily
with `edit` later. Be sure to use the shareable URL (rather than the one
in the omnibox) so that the ID is extractly correctly.'

x_add() {
  _filter "$@"
  (( $# == 2 )) || (echo "usage: $EXE add <name> <video>" && return 1)
  cd "$CLIP_DIR"
  local url="$2"
  local id="${url##*/}"
  youtube-dl "$url" -o "$id.%(ext)s"
  local name base
  path=$(ls "$CLIP_DIR/$id".*)
  file=${path##*/}
  base=${file%.*}
  echo "$1 100 0 9001 $file" >> "$CLIP_DATA"
  cd -
}

help[list]='
The `list` command display a space-delimited list of all possible, unique clip names sorted alphalexically.
'

x_list() {
  mapfile data < "$CLIP_DATA"
  data=($(printf "%s\n" "${data[@]%% *}" | sort -u))
  echo "${data[@]%% *}" 
}

help[dir]='The `dir` command prints the full path to the directory containing the videos used for all clips (`$CLIP_DIR`).'

x_dir() { echo "$CLIP_DIR"; }

help[usage]='The `usage` command print a summary of usage for this command.'

x_usage() {
    local cmds="${COMMANDS[*]}"
    printf "usage: %s (%s)\n" "${0##*/}" "${cmds// /|}"
}

help[help]='
The `help` command prints help information. If no argument is passed
displays general help information (main). Otherwise, the documentation
for the specific argument keyword is displayed, which usually
corresponds to a command name (but not necessarily). All documentation
is written in CommonMark (Markdown) and will displayed as Web page if
`pandoc` and `$HELP_BROWSER` are detected, otherwise, just the Markdown is
sent to `$PAGER` (default: more).'

x_help() { 
  local name="$1"
  if [[ -z "$name" ]];then
    for c in "${COMMANDS[@]}";do
      x_help "$c" buildonly
    done
    x_help main
    return 0
  fi
  local title="$EXE $name"
  [[ $name = main ]] && title="$EXE"
  local file="/tmp/help-$EXE-$name.html"
  if _have pandoc ; then
    if _have "$HELP_BROWSER" ;then
      pandoc -s --metadata title="$title" \
        -o "$file" <<< "${help[$name]}"
      [[ -z "$2" ]] && cd /tmp && exec "$HELP_BROWSER" "$file"
      return 0
    fi
    pandoc -s --metadata title="$title" \
      -t plain <<< "${help[$name]}" | "$PAGER"
    return 0
  fi
  echo "${help[$name]}" | "$PAGER"
}

# --------------------- completion and delegation --------------------

_have(){ type "$1" &>/dev/null; }

_filter(){
  (( $# > 0 )) && return 0
  while IFS= read -ra args; do
    "${FUNCNAME[1]}" "${args[@]}"
  done
}

while IFS= read -r line; do
    [[ $line =~ ^declare\ -f\ x_ ]] || continue
    COMMANDS+=( "${line##declare -f x_}" )
done < <(declare -F)

if [[ -n $COMP_LINE ]]; then
    line=${COMP_LINE#* }
    for c in "${COMMANDS[@]}" $(x_list); do
        [[ ${c:0:${#line}} == "${line,,}" ]] && echo "$c"
    done
    exit
fi

for c in "${COMMANDS[@]}"; do
    if [[ $c == "$EXE" ]]; then
        "x_$EXE" "$@"
        exit $?
    fi
done

declare cmd="$1"; shift || true
for c in "${COMMANDS[@]}"; do
    if [[ $c == "$cmd" ]]; then
        "x_$cmd" "$@"
        exit $?
    fi
done

x_play "$cmd"

