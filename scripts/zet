#!/bin/bash
set -e

# This zet script is a multicall executable, which means you may have
# opened another file or link which opened this.
#
# Add the following to bashrc to enable completion (replace zet with
# your multicall executable name):
#
#   complete -C zet zet
#
# Note that you will need one such complete line for every multicall
# variation of this script (ex: ln -s zet log; complete -C log log)

test -z "$GITUSER" && echo "GITUSER not set." && exit 1

# Check for $ZETDIR or $KN variables (in that order). If found, use
# those variables for the parent directory. If they do not exist, check
# for the existance of the default directory and create the folder if
# necessary. This not only allows for customization of the parent
# directory via $ZETDIR, but also allows for compatibility with the
# KEG/KN toolset.

test -d "$HOME/.local/share/zet" && pdir="$HOME/.local/share/zet"
test -d "$KN" && pdir="$KN"
test -d "$ZETDIR" && pdir="$ZETDIR"

EXE=${0##*/}
test -z "$EXE" && echo "Could not determine name of executable." && exit 1

# Add creates a Zettelkasten repo entry with an isosec unique directory
# name within the $KN/$EXE parent directory. Whatever the effective name
# of the executable (multicall, symlink, hardlink, alias, copy) will be
# used for $EXE. Opens editor with $EDITOR or vim.  Git commits using
# the first 50 characters of the first line (ignoring heading hashtags
# if prefixed) and pushes. Designed to be used in situations where
# commiting and pushing to main/master is allowed (which is usually fine
# for knowledge repos).

add() {
  test ! -d "$KN/$EXE" && echo "Directory not found: $KN/$EXE" && exit 1
  dir="$KN/$EXE/$(isosec)"
  mkdir -p "$dir"
  ${EDITOR:-vim} "$dir/README.md"
  cd "$dir"
  test -r "$dir/README.md" || rmdir "$dir"
  line=$(head -1 "$dir/README.md" | sed 's/#\+ *//')
  test -n "$line"
  echo "Adding: $line"
  git add -A "$dir"
  git commit -m "$line"
  git push
}

query() {
  test -z "$1" && echo "Missing search query." && exit 1
  type urlencode >/dev/null 2>&1
  term="$*"
  it="https://github.com/$GITUSER/$EXE/search?q=$(urlencode "$term")"
  echo "[$term]: <$it>"
  type wee >/dev/null 2>&1 || return 0
  open "$it"
}

titles() {
  test ! -d "$KN/$EXE" && echo "Directory not found: $KN/$EXE" && exit 1
  dir="$KN/$EXE"

  local -a zets=($(find "$dir" -maxdepth 2 -type d -path '*/20*' | sort ))

  local IFS=$'\n'
  for i in ${zets[@]}; do
    [[ -r "$i/README.md" ]] || continue
    echo "${i##*/}" $(head -1 "$i/README.md")
  done
}

_last() {
  local line=$(titles | tail -1)
  echo "* [${line##*\# }](https://github.com/$GITUSER/$EXE/tree/main/${line%% *})"
}

totxt() {
  local zet="$1"
  dir="$pdir/$EXE/$zet"
  [[ -r $dir/README.md ]] || return
  txt < $dir/README.md
}

remove() {
  local IFS=$'\n'
  cd "$pdir/$EXE"
  select title in `$EXE list`; do
    rm -rf "$pdir/$EXE/${title%% *}"
    git add "$pdir/$EXE"
    git commit -m "done"
    git push
    exit
  done
}

view() {
  local IFS=$'\n'
  cd "$pdir/$EXE"
  select title in `$EXE list`; do
    vim "$pdir/$EXE/${title%% *}/README.md"
    exit
  done
}

case "$1" in
add | "") add ;;
q | query)
  shift
  query "$@"
  ;;
l | ls | list | titles) titles ;;
rm | remove) remove ;;
v | view) view ;;
totxt) shift; totxt "$@";;
last) shift; _last "$@";;
*) echo Unsupported. ;;
esac
