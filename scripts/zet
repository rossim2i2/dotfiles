#!/usr/bin/bash
set -e

# This zet script is a multicall executable, which means you may have
# opened another file or link which opened this.
#
# Add the following to bashrc to enable completion (replace zet with
# your multicall executable name):
#
#   complete -C zet zet
#
# Note that you will need one such complete line for every multicall
# variation of this script (ex: ln -s zet log; complete -C log log)

test -z "$GITUSER" && echo "GITUSER not set." && exit 1

# Check for $ZETDIR or $KN variables (in that order). If found, use
# those variables for the parent directory. If they do not exist, check
# for the existance of the default directory and create the folder if
# necessary. This not only allows for customization of the parent
# directory via $ZETDIR, but also allows for compatibility with the
# KEG/KN toolset. This directory is expected to contain one or more
# subdirectories, each of which is usually a git repository that directly
# matches the name of the multicall executable (ex: $ZETDIR/zet).

test -d "$HOME/.local/share/zet" && ZETDIR="$HOME/.local/share/zet"
test -d "$KN" && ZETDIR="$KN"

EXE=${0##*/}
test -z "$EXE" && echo "Could not determine name of executable." && exit 1
DIR="$ZETDIR/$EXE"

# ----------------------------- commands -----------------------------

# Each reads the arguments as a template for a command to be passed to
# the command line. The syntax of the template uses Go templates (as
# popularized by Kubernetes). The following values can be wrapped in
# double curly brackets to be replaced before being called. If a value
# is emply the word 'null' will be replaced. By default, all markdown is
# converted into text with the pandoc command:
#
#   {{.ID}}          - isosec identifier
#   {{.Title}}       - full (converted) text of title
#   {{.Body}}        - all text (converted) but title and video
#   {{.Slug}}        - dashed slug derived from title
#   {{.Video}}       - full video URL (usually https://youtu.be/...)
#   {{.File.Dir}}    - full path to the zettel directory
#   {{.File.README}} - full path to the README.md file
#   {{.File.Data}}   - full path to the data.yaml file (even if not exists)
#   {{.Web.Dir}}     - curl-able URL to the zettel directory
#   {{.Web.README}}  - curl-able URL to raw README.md file
#   {{.Web.Data}}    - curl-able URL to raw data.yaml file
#   {{.Data.*}}      - reference to data from the parsed data.yaml file
#   {{.Raw.Title}}   - raw markdown of title (including initial #)
#   {{.Raw.Body}}    - raw markdown of body
#   {{.Raw.README}}  - raw markdown entire README.md file
#   {{.Raw.Data}}    - raw YAML from data.yaml file
#
# The order is always sorted by isosec meaning that the newest will
# always be last.

x_each() {
  if [[ $# == 0 ]];then
    x_each "echo"
    return $?
  fi
  local dir=$(x_d)
  for i in $(x_ids); do
    "$@" "$dir/$i/README.md"
  done
}

# Grep is simply a shortcut for `zet each grep "$@"` running the system
# grep on all the main zettel README.md files passing the arguments
# as-is to the grep command (-P for PRCE, etc.)

x_grep() {
  x_each grep "$@"
}

x_open() {
  local zetid="$1"
  [[ -z "$zetid" || $zetid = last ]] && zetid=$(x_last)
  open "https://github.com/rwxrob/zet/tree/main/$zetid"
}

x_usage() {
    local cmds="${COMMANDS[@]}"
    printf "usage: ${0##*/} (${cmds// /|})\n"
}

x_commit() {

  # recurse if called as filter
  local IFS=$'\n'
  if [[ -z "$1" ]]; then
    while read -r line; do
      x_commit $line
    done
    return 0
  fi

  # if no zet, bail
  local dir="$(x_d)/$1"
  local readme="$dir/README.md"
  [[ ! -r $readme ]] && echo "<not found: $1>" && return 1

  # git commit keeping title as commit message 
  local title=$(x_title)
  cd "$dir"
  pwd
  echo -n "... "
  git add -A "$dir" &>/dev/null
  git commit -m "$title" &>/dev/null || true
  git push &>/dev/null
  echo Commited.
  cd -

}

x_video() {

  # recurse if called as filter
  local IFS=$'\n'
  if [[ -z "$1" ]]; then
    while read -r line; do
      x_video $line
    done
    return 0
  fi

  # accept zet or yt ids  
  local zetid ytid changed
  if [[ $1 =~ ^[0-9]{14,}$ ]]; then
    zetid="$1"
    ytid="${2##*/}"
  elif [[ $1 = last ]]; then
    zetid=$(x_last)
    ytid="${2##*/}"
  else
    ytid="${1##*/}"
    zetid=$(yt zet "$1")
  fi

  # if no zet, bail
  local dir="$(x_d)/$zetid"
  local readme="$dir/README.md"
  [[ ! -r $readme ]] && echo "<not found: $zetid/$ytid>" && return 1

  # if zet has vid line...
  if [[ $(sed '3q;d' "$readme") =~ ^ðŸ“º\ \<https://youtu.be/(.*)\> ]]; then

    # update if ytid 
    if [[ -n "$ytid" ]]; then
      echo -e "3c\nðŸ“º <https://youtu.be/$ytid>\n.\nwq" | ed "$readme" >/dev/null
      changed=1

    # read it to print later
    else
      ytid=${BASH_REMATCH[1]}
    fi

  # zet does not have vid line
  else

    # so add it if have video id
    if [[ -n "$ytid" ]]; then
      echo -e "2a\nðŸ“º <https://youtu.be/$ytid>\n\n.\nwq" | ed "$readme" >/dev/null
      changed=1
    fi
  fi

  # always print the url to the video id
  if [[ -n "$ytid" ]]; then
    echo "https://youtu.be/$ytid"
    [[ $changed = 1 ]] && x_commit "$zetid"
  else
    echo "<no video found in $zetid>"
  fi
}
x_v() { x_video "$@"; }

x_urlencode() {
  local string="$*"
  if [[ -z $string ]]; then
    local IFS=$'\n'
    while read -r line; do
      x_urlencode "$line"
    done
  fi
  local strlen=${#string}
  local encoded=""
  local pos c o
  for ((pos = 0; pos < strlen; pos++)); do
    c=${string:$pos:1}
    case "$c" in
    [-_.~a-zA-Z0-9]) o="${c}" ;;
    *) printf -v o '%%%02x' "'$c" ;;
    esac
    encoded+="${o}"
  done
  echo "${encoded}"
}

x_id() { date -u +%Y%m%d%H%M%S; }

x_dir() { [[ -d $DIR ]] && echo "$DIR"; }
x_d() { x_dir "$@"; }

# Add creates a Zettelkasten repo entry with an isosec unique directory
# name within the $KN/$EXE parent directory. Whatever the effective name
# of the executable (multicall, symlink, hardlink, alias, copy) will be
# used for $EXE. Opens editor with $EDITOR or vim.  Git commits using
# the first 50 characters of the first line (ignoring heading hashtags
# if prefixed) and pushes. Designed to be used in situations where
# commiting and pushing to main/master is allowed (which is usually fine
# for knowledge repos).

x_add() {
  local dir="$(x_d)/$(x_id)"
  local readme="$dir/README.md"
  mkdir -p "$dir"
  "${EDITOR:-vim}" "$readme"
  cd "$dir"
  # TODO bail if file is zero length
  line=$(head -1 "$dir/README.md" | sed 's/#\+ *//')
  test -n "$line"
  echo "Adding: $line"
  git add -A "$dir" &>/dev/null
  git commit -m "$line" &>/dev/null
  git push &>/dev/null
}
x_a() { x_add "$@"; }

x_edit() {
  local dir
  if [[ $1 =~ ^[0-9]{14,}$ ]]; then
    dir="$(x_d)/$1"
  elif [[ $1 = last ]]; then
    dir="$(x_d)/$(x_last)"
  else
    local zetid=$(yt zet "$1")
    if [[ -z "$zetid" ]]; then
      echo "Unable to determine zet id for $1"
      return 1
    fi
    dir="$(x_d)/$zetid"
  fi
  local readme="$dir/README.md"
  [[ ! -r $readme ]] && echo "Not found." && return 1
  "${EDITOR:-vim}" "$readme"
  # TODO prompt for "save" (git commit)
}
x_e() { x_edit "$@"; }

x_titles() {
  local dir=$(x_d)
  local -a zets=($(find "$dir" -maxdepth 2 -type d -path '*/2*'|sort ))
  local IFS=$'\n'
  local buf
  for i in ${zets[@]}; do
    [[ -r "$i/README.md" ]] || continue
    local title=$(head -1 "$i/README.md")
    [[ $title =~ ^#\  ]] || title="<untitled>"
    title="${title#*# }"
    buf="$buf${i##*/} ${title#*# }  "$'\n'
  done
  pandoc -t plain --wrap=none <<< "$buf"
}
x_ls() { x_titles "$@"; }

x_last() {
  local IFS=$'\n'
  local -a titles=($(x_titles))
  local last=${#titles[@]}
  echo "${titles[$last-1]%% *}"
  #echo "* [${line#* }](https://github.com/rwxrob/zet/tree/main/${line%% *})"
}

x_text() {
  local dir="$(x_d)/$1"
  local readme="$dir/README.md"
  [[ -r $readme ]] || return 1
  local pandoc=$(command -v pandoc)
  [[ -z $pandoc ]] && echo "'$EXE text' requires pandoc" && return 1
  pandoc -t plain --wrap=none < "$readme"
}

x_title() {
  local dir="$(x_d)/$1"
  [[ -d $dir ]] || return 1
  local readme="$dir/README.md"
  read -r title < $readme
  [[ ! $title =~ ^#\  ]] && return 1
  pandoc -t plain --wrap=none <<< "${title#\# }"
}

x_body() {
  local dir="$(x_d)/$1"
  [[ -d $dir ]] || return 1
  local readme="$dir/README.md"
  local buf=$(<$readme)
  local eol=$'\n'
  [[ $buf =~ ^\#\  ]] && buf=${buf#*$eol$eol} 
  buf=${buf#ðŸ“º *$eol$eol}
  pandoc -t plain --wrap=none <<< "$buf"
}

x_query() {
  [[ -z "$1" ]] && echo "Missing search query." && return 1
  term="$*"
  it="https://github.com/$GITUSER/$EXE/search?q=$(x_urlencode $term)"
  echo "[$term]: <$it>"
  local chat=$(command -v chat)
  [[ -z $chat ]] && return 0
  exec chat "$it"
}
x_q() { x_query "$@"; }

x_ids() {
  while read -r line; do
    echo "${line##*/}"
  done < <(find "$(x_d)" -maxdepth 2 -type d -path '*/2*'| sort)
}

x_before() {
  local id=$1
  local prev
  while read -r cur; do
    (( $cur > $id )) && break
    prev=$cur
  done < <(x_ids)
  echo $prev
}

x_for() {
  local mkv="$1"
  [[ $mkv == last ]] && mkv=$(mkvlast)
  [[ $mkv =~ - ]] && mkv=$(mkv2isosec "$mkv")
  local id=${mkv##*/}
  id=${id%.mkv}
  zet before $id
}

x_after() {
  local id=$1
  while read -r cur; do
    (( cur > $id )) && break
  done < <(x_ids)
  echo $cur
}

x_remove() {
  local dir=$(x_d)
  local IFS=$'\n'
  cd "$dir"
  select title in `$EXE titles`; do
    rm -rf "$dir/${title%% *}"
    git add "$dir"
    git commit --quiet -m "done"
    git push --quiet
    echo "Marked as done"
    exit
  done
}
x_rm() { x_remove "$@"; }

x_view() {
  local dir=$(x_d)
  local IFS=$'\n'
  cd "$dir"
  select title in `$EXE titles`; do
    vim "$dir/${title%% *}/README.md"
    exit
  done
}

# --------------------- completion and delegation --------------------

declare -a COMMANDS=()

while read -r line; do
    [[ $line =~ ^declare\ -f\ x_ ]] || continue
    COMMANDS+=( ${line##declare -f x_} )
done < <(declare -F)

if [[ -n $COMP_LINE ]]; then
    for c in "${COMMANDS[@]}"; do
        [[ ${c:0:${#2}} == "${2,,}" ]] && echo "$c"
    done
    exit
fi

declare cmd="$1"; shift
for c in "${COMMANDS[@]}"; do
    if [[ $c == "$cmd" ]]; then
        "x_$cmd" "$@"
        exit $?
    fi
done

x_usage "$@"

